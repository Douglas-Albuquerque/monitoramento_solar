#!/usr/bin/env python3
"""
Robô Solar Dashboard - Coleta status das usinas e grava no MariaDB.
"""

import os
import base64
import json
import requests
from requests.exceptions import HTTPError
from datetime import datetime, timedelta, timezone

from dotenv import load_dotenv
import mysql.connector
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
)  # [file:20]
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), "..", ".env"))

# ========== CONFIGURAÇÃO DAS USINAS ==========
# Preencha com os dados reais (URL e seletores)
USINAS = [
    {
        "nome": "UFV-ATLANTA",
        "responsavel": "Edson - 85988066711",
        "tipo": "growatt_api",
        "plant_id": 310511,  # plant_id que você recebeu da API
        "token_env": "GROWATT_TOKEN_ATLANTA",
        "limite_kw_online": 0.1,  # >0.1 kW consideramos ONLINE
        ##################################
        # dados para fallback via Selenium:
        ##################################
        "nome": "UFV-ATLANTA",
        "responsavel": "Edson - 85988066711",
        "url_login": "http://server.growatt.com",  # URL de login
        "usuario_env": "SITE1_USER",  # variável no .env
        "senha_env": "SITE1_PASS",  # variável no .env
        "user_sel": "input[name='username']",  # CSS selector campo usuário
        "pass_sel": "input[name='password']",  # CSS selector campo senha
        "btn_sel": "button.hasColorBtn.loginB",  # CSS selector botão login
        "status_sel": "span.green",  # CSS selector onde aparece Online/Offline
        "online_texto": "connected",  # texto que indica ONLINE
    },
    {
        "nome": "UFV CASA 4",
        "responsavel": "Elizaldo - 85988858352",
        "url_dashboard": "https://home.solarmanpv.com/plant/infos/data",
        "usa_cookies": True,
        "cookie_file": "cookies/cookies_solarman.pkl",
        "status_sel": "span.station-status",
        "online_texto": "normal",
    },
    {
        "nome": "UFV-HELENA-1",
        "responsavel": "Elizaldo - 85988858352",
        "tipo": "growatt_api",
        "plant_id": 2480414,
        "token_env": "GROWATT_TOKEN_HELENA1",
        "limite_kw_online": 0.1,
        ##################################
        # dados para fallback via Selenium:
        ##################################
        # "nome": "UFV-HELENA-1",
        # "responsavel": "Elizaldo - 85988858352",
        # "url_login": "http://server.growatt.com",  # URL de login
        # "usuario_env": "SITE3_USER",  # variável no .env
        # "senha_env": "SITE3_PASS",  # variável no .env
        # "user_sel": "input[name='username']",  # CSS selector campo usuário
        # "pass_sel": "input[name='password']",  # CSS selector campo senha
        # "btn_sel": "button.hasColorBtn.loginB",  # CSS selector botão login
        # "status_sel": "span.green",  # CSS selector onde aparece Online/Offline
        # "online_texto": "connected",  # texto que indica ONLINE
    },
    {
        "nome": "UFV HELENA-2",
        "responsavel": "Edson - 85988066711",
        "url_login": "https://web3.isolarcloud.com.hk/#/login",
        "usuario_env": "SITE4_USER",
        "senha_env": "SITE4_PASS",
        "user_sel": "input[placeholder='Account']",
        "pass_sel": "input[placeholder='Password']",
        "btn_sel": "div.el-form-item__content button.el-button",
        "status_sel": "td.el-table_1_column_4.plant-list-cell.el-table__cell div.plant-status-column",  # "td.el-table_1_column_4.plant-list-cell.el-table__cell div.plant-status-column"
        "online_texto": "Normal",  # padrão de online é "Normal"
    },
]

# =============================================


def get_db_connection():
    return mysql.connector.connect(
        unix_socket="/var/run/mysqld/mysqld.sock",
        user=os.getenv("DB_USER", "solar_user"),
        password=os.getenv("DB_PASS"),
        database=os.getenv("DB_NAME", "solar_monitor"),
    )


def obter_status_anterior(nome_usina: str) -> str:
    """Busca o último status salvo para a usina (ou None)."""
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT status
        FROM usinas_status
        WHERE nome_usina = %s
        """,
        (nome_usina,),
    )
    row = cur.fetchone()
    cur.close()
    conn.close()
    return row[0] if row else None


def salvar_status(nome_usina: str, status: str):
    """Insere ou atualiza status da usina na tabela usinas_status."""
    conn = get_db_connection()
    cur = conn.cursor()
    agora = datetime.now()

    cur.execute(
        """
        INSERT INTO usinas_status (nome_usina, status, updated_at)
        VALUES (%s, %s, %s)
        ON DUPLICATE KEY UPDATE
            status = VALUES(status),
            updated_at = VALUES(updated_at)
        """,
        (nome_usina, status, agora),
    )

    conn.commit()
    cur.close()
    conn.close()


GROWATT_API_BASE = "https://openapi.growatt.com/v1"


def get_growatt_headers(cfg: dict):
    token_env = cfg.get("token_env")
    if not token_env:
        raise RuntimeError(f"token_env não definido para {cfg['nome']}")
    token = os.getenv(token_env)
    if not token:
        raise RuntimeError(f"Variável {token_env} não encontrada no .env")
    return {"token": token}


def checar_usina_growatt_api(cfg: dict) -> str:
    nome = cfg["nome"]
    plant_id = cfg["plant_id"]
    limite_kw = cfg.get("limite_kw_online", 0.1)

    limite_minutos_offline = 10
    limite_minutos_erro = 30

    try:
        url = f"{GROWATT_API_BASE}/plant/data"
        params = {"plant_id": plant_id}
        resp = requests.get(
            url,
            headers=get_growatt_headers(cfg),
            params=params,
            timeout=15,
        )

        try:
            resp.raise_for_status()
        except HTTPError as http_err:
            status_code = resp.status_code
            print(f"[{nome}] HTTP ERRO API Growatt ({status_code}): {http_err}")
            if 500 <= status_code < 600:
                print(f"[{nome}] API 5xx, tentando fallback via Selenium...")
                try:
                    return checar_usina(cfg)  # usa Selenium com os campos do cfg
                except Exception as e2:
                    print(f"[{nome}] Fallback Selenium também falhou: {e2}")
                    status_antigo = obter_status_anterior(nome)
                    return status_antigo or "ERRO"
            return "ERRO"

        payload = resp.json()
        if payload.get("error_code") != 0:
            err = payload.get("error_msg")
            print(f"[{nome}] ERRO API: {err}")
            if err == "error_frequently_access":
                print(f"[{nome}] Rate limit na API, tentando fallback via Selenium...")
                try:
                    return checar_usina(cfg)
                except Exception as e2:
                    print(f"[{nome}] Fallback Selenium também falhou: {e2}")
                    status_antigo = obter_status_anterior(nome)
                    return status_antigo or "ERRO"
            return "ERRO"

        data = payload.get("data", {}) or {}
        current_power = float(data.get("current_power", 0) or 0)
        last_update_raw = (data.get("last_update_time") or "").strip()

        print(
            f"[{nome}] current_power = {current_power} kW, "
            f"last_update_time = {last_update_raw}"
        )

        minutos_diferenca = None
        if last_update_raw:
            try:
                dt_local = datetime.strptime(last_update_raw, "%Y-%m-%d %H:%M:%S")
                dt_local = dt_local.replace(tzinfo=timezone(timedelta(hours=-3)))
                agora_local = datetime.now(timezone(timedelta(hours=-3)))
                minutos_diferenca = (agora_local - dt_local).total_seconds() / 60.0
            except Exception as e:
                print(f"[{nome}] ERRO ao parsear last_update_time: {e}")
                minutos_diferenca = None

        if (
            minutos_diferenca is not None
            and minutos_diferenca <= limite_minutos_offline
        ):
            return "ONLINE"

        if current_power > limite_kw:
            return "ONLINE"

        if (
            minutos_diferenca is not None
            and limite_minutos_offline < minutos_diferenca <= limite_minutos_erro
        ):
            return "OFFLINE"

        if minutos_diferenca is not None and minutos_diferenca > limite_minutos_erro:
            return "ERRO"

        status_antigo = obter_status_anterior(nome)
        print(f"[{nome}] Sem info confiável, mantendo status anterior: {status_antigo}")
        return status_antigo or "ERRO"

    except Exception as e:
        print(f"[{nome}] ERRO API Growatt: {e}")
        # último recurso: tentar Selenium uma vez
        try:
            print(f"[{nome}] Tentando Selenium como último recurso...")
            return checar_usina(cfg)
        except Exception as e2:
            print(f"[{nome}] Selenium também falhou: {e2}")
            return "ERRO"


def enviar_whatsapp_alerta(
    nome_usina: str, status_novo: str, status_antigo: str = None, responsavel: str = ""
):
    base_url = os.getenv("EVOLUTION_BASE_URL", "http://10.254.2.210:5080")
    instance = os.getenv("EVOLUTION_INSTANCE", "Solar")
    api_key = os.getenv("EVOLUTION_API_KEY", "F0R$@tl1")
    numero = os.getenv("WHATSAPP_NUMBER_ALERTA", "5585981699862")

    url = f"{base_url}/message/sendText/{instance}"

    texto = (
        "ALERTA MONITORAMENTO SOLAR\n\n"
        f"Usina: {nome_usina}\n"
        f"Status atual: {status_novo}\n"
        # f"Status anterior: {status_antigo or 'desconhecido'}\n"
        f"Responsável técnico: {responsavel or 'não cadastrado'}\n"
        f"Data/hora: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}"
    )

    payload = {
        "number": numero,
        "text": texto,
        "options": {
            "delay": 1200,
            "presence": "composing",
            "linkPreview": False,
        },
    }

    headers = {
        "apikey": api_key,
        "Content-Type": "application/json",
    }

    try:
        resp = requests.post(url, headers=headers, json=payload, timeout=15)
        print(f"[WHATSAPP] HTTP {resp.status_code} - {resp.text}")
    except Exception as e:
        print(f"[WHATSAPP] Erro ao enviar alerta: {e}")


def criar_driver():
    options = Options()
    options.add_argument("--headless=new")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-gpu")
    options.add_argument("--window-size=1920,1080")
    options.add_argument("--remote-debugging-port=9222")

    # usa o Chrome que você acabou de instalar:
    options.binary_location = "/usr/bin/google-chrome"

    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=options)
    return driver


def checar_usina(cfg: dict) -> str:
    """Faz login em uma usina e detecta se está ONLINE ou OFFLINE."""  # [file:20]
    driver = criar_driver()
    status_final = "ERRO"

    nome = cfg["nome"]
    debug_dir = os.path.join(os.path.dirname(__file__), "..", "debug")
    os.makedirs(debug_dir, exist_ok=True)

    try:
        print(f"[{nome}] 1. Acessando URL: {cfg['url_login']}")
        driver.get(cfg["url_login"])

        import time

        print(f"[{nome}] 1.5. Aguardando SPA carregar...")
        time.sleep(8)  # espera 8 segundos para o Vue/React renderizar

        try:
            print(f"[{nome}] 1.6. Fechando banner cookies...")
            cookie_disagree = driver.find_element(
                By.XPATH, "//button[contains(., 'I disagree')]"
            )
            cookie_disagree.click()
            time.sleep(2)
            print(f"[{nome}] 1.7. Cookies fechados")
        except Exception:
            print(f"[{nome}] 1.7. Sem banner cookies")
            pass

        driver.save_screenshot(f"{debug_dir}/{nome}_01_inicial.png")

        wait = WebDriverWait(driver, 30)

        # Campo usuário
        print(f"[{nome}] 2. Procurando campo usuário: {cfg['user_sel']}")
        el_user = wait.until(
            EC.presence_of_element_located((By.CSS_SELECTOR, cfg["user_sel"]))
        )
        el_user.clear()
        el_user.send_keys(os.getenv(cfg["usuario_env"]))
        driver.save_screenshot(f"{debug_dir}/{nome}_02_usuario_preenchido.png")

        # Campo senha
        print(f"[{nome}] 3. Procurando campo senha: {cfg['pass_sel']}")
        el_pass = driver.find_element(By.CSS_SELECTOR, cfg["pass_sel"])
        el_pass.clear()
        el_pass.send_keys(os.getenv(cfg["senha_env"]))
        driver.save_screenshot(f"{debug_dir}/{nome}_03_senha_preenchida.png")

        # Botão login
        print(f"[{nome}] 4. Procurando botão: {cfg['btn_sel']}")
        btn = driver.find_element(By.CSS_SELECTOR, cfg["btn_sel"])
        driver.execute_script("arguments[0].scrollIntoView(true);", btn)
        driver.save_screenshot(f"{debug_dir}/{nome}_04_antes_clicar.png")

        try:
            btn.click()
        except Exception:
            driver.execute_script("arguments[0].click();", btn)

        print(f"[{nome}] 5. Login clicado, aguardando...")
        time.sleep(5)  # espera carregar
        driver.save_screenshot(f"{debug_dir}/{nome}_05_apos_login.png")

        # Esperar elemento de status aparecer
        print(f"[{nome}] 6. Procurando status: {cfg['status_sel']}")

        try:
            # 1ª tentativa: seletor CSS configurado (ex.: span.green)
            el_status = wait.until(
                EC.presence_of_element_located((By.CSS_SELECTOR, cfg["status_sel"]))
            )
        except TimeoutException:
            # 2ª tentativa (Growatt): célula que contém "Connection Status"
            print(
                f"[{nome}] 6b. Não achei '{cfg['status_sel']}', tentando XPath do texto..."
            )
            el_status = wait.until(
                EC.presence_of_element_located(
                    (
                        By.XPATH,
                        "//td[contains(normalize-space(.), 'Connection Status')]//span/span",
                    )
                )
            )

        driver.save_screenshot(f"{debug_dir}/{nome}_06_status_encontrado.png")

        texto = (el_status.text or "").strip().lower()
        print(f"[{nome}] 7. Texto lido: '{texto}'")

        # para Growatt e demais: só "connected" é ONLINE; qualquer outro texto => OFFLINE
        if cfg["online_texto"].lower() in texto:
            status_final = "ONLINE"
        else:
            status_final = "OFFLINE"

    except Exception as e:
        print(f"[{nome}] ERRO DETALHADO: {type(e).__name__}: {str(e)}")
        driver.save_screenshot(f"{debug_dir}/{nome}_99_erro.png")

        # Salvar HTML para análise
        with open(f"{debug_dir}/{nome}_erro.html", "w", encoding="utf-8") as f:
            f.write(driver.page_source)

        status_final = "ERRO"
    finally:
        driver.quit()

    return status_final


def checar_usina_cookies(cfg: dict) -> str:
    """Usina que usa cookies (sem login)."""
    import pickle, json, time

    driver = criar_driver()
    status_final = "ERRO"
    nome = cfg["nome"]

    cookie_path = os.path.join(os.path.dirname(__file__), "..", cfg["cookie_file"])

    try:
        print(f"[{nome}] 1. Carregando cookies...")

        if not os.path.exists(cookie_path):
            print(f"[{nome}] ERRO: {cookie_path} não encontrado!")
            return "ERRO"

        driver.get(cfg["url_dashboard"])
        time.sleep(2)

        # Detecta pelo sufixo se é pickle (.pkl) ou json
        if cfg["cookie_file"].endswith(".pkl"):
            with open(cookie_path, "rb") as f:
                cookies = pickle.load(f)
        else:
            with open(cookie_path, "r", encoding="utf-8") as f:
                cookies = json.load(f)

        for cookie in cookies:
            try:
                c = cookie.copy()
                c.pop("sameSite", None)
                driver.add_cookie(c)
            except Exception:
                pass

        print(f"[{nome}] 2. Cookies carregados, acessando dashboard...")
        driver.refresh()
        time.sleep(8)

        print(f"[{nome}] 3. Procurando status: {cfg['status_sel']}")
        el_status = driver.find_element(By.CSS_SELECTOR, cfg["status_sel"])
        texto = (el_status.text or "").strip().lower()
        print(f"[{nome}] 4. Texto lido: '{texto}'")

        if cfg["online_texto"].lower() in texto:
            status_final = "ONLINE"
        elif "offline" in texto or "desligado" in texto:
            status_final = "OFFLINE"
        else:
            status_final = "ERRO"

    except Exception as e:
        print(f"[{nome}] ERRO: {e}")
        status_final = "ERRO"
    finally:
        driver.quit()

    return status_final


def verificar_expiracao_cookies(cookie_file: str, dias_aviso: int = 5) -> dict:
    """
    Verifica se cookies estão próximos de expirar.
    Retorna: {"expira_em_dias": X, "precisa_renovar": True/False}
    """
    import pickle

    cookie_path = os.path.join(os.path.dirname(__file__), "..", cookie_file)

    if not os.path.exists(cookie_path):
        return {
            "expira_em_dias": 0,
            "precisa_renovar": True,
            "erro": "Arquivo não encontrado",
        }

    try:
        with open(cookie_path, "rb") as f:
            cookies = pickle.load(f)

        # Procurar token JWT (geralmente tem "exp" nele)
        for cookie in cookies:
            if "value" in cookie and cookie["value"].startswith("eyJ"):
                # É um JWT, decodificar
                try:
                    # JWT formato: header.payload.signature
                    payload_b64 = cookie["value"].split(".")[1]
                    # Adicionar padding se necessário
                    payload_b64 += "=" * (4 - len(payload_b64) % 4)
                    payload_json = base64.b64decode(payload_b64).decode("utf-8")
                    payload = json.loads(payload_json)

                    if "exp" in payload:
                        exp_timestamp = payload["exp"]
                        exp_date = datetime.fromtimestamp(exp_timestamp)
                        agora = datetime.now()
                        dias_restantes = (exp_date - agora).days

                        return {
                            "expira_em_dias": dias_restantes,
                            "expira_em": exp_date.strftime("%d/%m/%Y %H:%M"),
                            "precisa_renovar": dias_restantes <= dias_aviso,
                        }
                except Exception as e:
                    continue

        return {
            "expira_em_dias": -1,
            "precisa_renovar": False,
            "erro": "Sem JWT nos cookies",
        }

    except Exception as e:
        return {"expira_em_dias": 0, "precisa_renovar": True, "erro": str(e)}


def main():
    print("=== Iniciando coleta de status das usinas ===")

    # Verificar cookies antes de começar
    cookies_verificados = set()

    for cfg in USINAS:
        if cfg.get("usa_cookies") and cfg["cookie_file"] not in cookies_verificados:
            cookies_verificados.add(cfg["cookie_file"])
            info = verificar_expiracao_cookies(cfg["cookie_file"])

            if info.get("precisa_renovar"):
                dias = info.get("expira_em_dias", 0)
                if dias > 0:
                    print(
                        f"\n⚠️  AVISO: Cookies de {cfg['nome']} expiram em {dias} dias ({info.get('expira_em')})"
                    )
                    print(
                        f"    Renove antes de {info.get('expira_em')} para evitar falhas!\n"
                    )
                else:
                    print(
                        f"\n❌ URGENTE: Cookies de {cfg['nome']} expiraram ou estão inválidos!"
                    )

    # Coletar status normalmente
    for cfg in USINAS:
        nome = cfg["nome"]
        responsavel = cfg.get("responsavel", "")
        print(f"-> Checando {nome} ...")

        if cfg.get("tipo") == "growatt_api":
            status_novo = checar_usina_growatt_api(cfg)
        elif cfg.get("usa_cookies"):
            status_novo = checar_usina_cookies(cfg)
        else:
            status_novo = checar_usina(cfg)

        status_antigo = obter_status_anterior(nome)
        salvar_status(nome, status_novo)
        print(f"   {nome}: {status_novo} (antes: {status_antigo})")

        # Enviar alerta **apenas quando houver mudança** para estado crítico
        if status_novo in ("OFFLINE", "ERRO") and status_novo != status_antigo:
            print(
                f"[ALERTA] {nome} em estado crítico ({status_antigo} -> {status_novo}). Enviando WhatsApp..."
            )
            enviar_whatsapp_alerta(nome, status_novo, status_antigo, responsavel)


if __name__ == "__main__":
    main()
